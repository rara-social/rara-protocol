type User @entity {
  id: ID! #publicAddress
}

type UserEarnings @entity {
  id: ID! #publicAddress + paymentToken
  paymentToken: Bytes!
  makerRewardsBalance: BigDecimal!
  creatorRewardsBalance: BigDecimal!
  referrerRewardsBalance: BigDecimal!

  makerRewardsTotal: BigDecimal!
  creatorRewardsTotal: BigDecimal!
  referrerRewardsTotal: BigDecimal!

  withdrawTotal: BigDecimal!
}

type Source @entity {
  id: ID! #sourceId
  sourceId: BigInt!
  nftChainId: BigInt!
  nftContractAddress: Bytes!
  nftId: BigInt!
  nftOwnerAddress: Bytes!
  nftCreatorAddress: Bytes!
  creatorSaleBasisPoints: BigInt!
  registered: Boolean!
  user: User!
}

type Transform @entity {
  id: ID! #transformId
  transformId: BigInt!
  optionBits: BigInt!
  source: Source!
  totalSold: BigInt!
}

type Reaction @entity {
  id: ID! #reactionId
  transform: Transform!
  parameterVersion: BigInt!

  totalSold: BigInt!
  referrerFeesTotal: BigDecimal!
  creatorFeesTotal: BigDecimal!
  makerFeesTotal: BigDecimal!
}

type UserReaction @entity {
  id: ID! #reactionId + msg.sender
  user: User!
  reaction: Reaction!
  quantityPurchased: BigInt!
  quantityAvailable: BigInt!
}

type UserSpend @entity {
  id: ID! #event.transaction.hash.toHex() + "-" + event.logIndex.toString()
  user: User!
  reaction: Reaction!
  quantity: BigInt!
  ipfsMetadataHash: BigInt
  curatorVault: CuratorVaultToken!
  tokensPurchased: BigInt!
}

type CuratorVaultToken @entity {
  id: ID! #curatorTokenId
  curatorVaultAddress: Bytes!
  curatorTokenId: BigInt!
  nftChainId: BigInt!
  nftContractAddress: Bytes!
  nftId: BigInt!
  paymentToken: Bytes!

  tokensOutstanding: BigInt!
  currentBalance: BigDecimal!

  tokensTotal: BigInt!
  depositsTotal: BigDecimal!
}

type UserPosition @entity {
  id: ID! # if sender: msg.sender + curatorTokenId, if taker: curatorTokenId
  user: User!
  isTakerPostion: Boolean!
  curatorVaultToken: CuratorVaultToken!

  tokensAvailable: BigInt!

  tokensTotal: BigInt!
  refundsTotal: BigDecimal!
}
