{
  "language": "Solidity",
  "sources": {
    "contracts/Maker/MakerRegistrar.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"../Permissions/IRoleManager.sol\";\nimport \"./IMakerRegistrar.sol\";\nimport \"./MakerRegistrarStorage.sol\";\nimport \"./NftOwnership.sol\";\nimport \"../Royalties/Royalties.sol\";\n\n/// @title MakerRegistrar\n/// @dev This contract tracks registered NFTs.  Owners of an NFT can register\n/// and deregister any NFTs owned in their wallet.\n/// Also, for the mappings, it is assumed the protocol will always look up the current owner of\n/// an NFT when running logic (which is why the owner address is not stored).  If desired, an\n/// off-chain indexer like The Graph can index registration addresses to NFTs.\ncontract MakerRegistrar is Initializable, MakerRegistrarStorageV1 {\n    /// @dev Event triggered when an NFT is registered in the system\n    event Registered(\n        uint256 nftChainId,\n        address indexed nftContractAddress,\n        uint256 indexed nftId,\n        address indexed nftOwnerAddress,\n        address[] nftCreatorAddresses,\n        uint256[] creatorSaleBasisPoints,\n        uint256 optionBits,\n        uint256 sourceId,\n        uint256 transformId,\n        string ipfsMetadataHash\n    );\n\n    /// @dev Event triggered when an NFT is deregistered from the system\n    event Deregistered(\n        uint256 nftChainId,\n        address indexed nftContractAddress,\n        uint256 indexed nftId,\n        address indexed nftOwnerAddress,\n        uint256 sourceId\n    );\n\n    /// @dev initializer to call after deployment, can only be called once\n    function initialize(IAddressManager _addressManager) public initializer {\n        addressManager = _addressManager;\n    }\n\n    function deriveSourceId(\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId\n    ) external pure returns (uint256) {\n        return _deriveSourceId(chainId, nftContractAddress, nftId);\n    }\n\n    function _deriveSourceId(\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId\n    ) internal pure returns (uint256) {\n        return\n            uint256(keccak256(abi.encode(chainId, nftContractAddress, nftId)));\n    }\n\n    /// @dev For the specified NFT, verify it is owned by the potential owner\n    function verifyOwnership(\n        address nftContractAddress,\n        uint256 nftId,\n        address potentialOwner\n    ) public view returns (bool) {\n        return\n            NftOwnership._verifyOwnership(\n                nftContractAddress,\n                nftId,\n                potentialOwner\n            );\n    }\n\n    /// @dev Allows a NFT owner to register the NFT in the protocol so that reactions can be sold.\n    /// Owner registering must own the NFT in the wallet calling function.\n    function registerNft(\n        address nftContractAddress,\n        uint256 nftId,\n        address creatorAddress,\n        uint256 creatorSaleBasisPoints,\n        uint256 optionBits,\n        string calldata ipfsMetadataHash\n    ) external {\n        // Verify ownership\n        require(\n            verifyOwnership(nftContractAddress, nftId, msg.sender),\n            \"NFT not owned\"\n        );\n\n        // Get the royalties for the creator addresses - use fallback if none set on chain\n        (\n            address[] memory addressesArray,\n            uint256[] memory creatorBasisPointsArray\n        ) = Royalties._getRoyaltyOverride(\n                addressManager.royaltyRegistry(),\n                nftContractAddress,\n                nftId,\n                creatorAddress,\n                creatorSaleBasisPoints\n            );\n\n        _registerForOwner(\n            msg.sender,\n            block.chainid, // Use current chain ID\n            nftContractAddress,\n            nftId,\n            addressesArray,\n            creatorBasisPointsArray,\n            optionBits,\n            ipfsMetadataHash\n        );\n    }\n\n    function registerNftFromBridge(\n        address owner,\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId,\n        address[] memory creatorAddresses,\n        uint256[] memory creatorSaleBasisPoints,\n        uint256 optionBits,\n        string calldata ipfsMetadataHash\n    ) external {\n        // Verify caller is Child Registrar from the bridge\n        require(msg.sender == addressManager.childRegistrar(), \"Not Bridge\");\n\n        _registerForOwner(\n            owner,\n            chainId,\n            nftContractAddress,\n            nftId,\n            creatorAddresses,\n            creatorSaleBasisPoints,\n            optionBits,\n            ipfsMetadataHash\n        );\n    }\n\n    /// @dev Register an NFT from an owner\n    /// @param owner - The current owner of the NFT - should be verified before calling\n    /// @param chainId - Chain where NFT lives\n    /// @param nftContractAddress - Address of NFT to be registered\n    /// @param nftId - ID of NFT to be registered\n    /// @param creatorAddresses - (optional) Address of the creator to give creatorSaleBasisPoints cut of Maker rewards\n    /// @param creatorSaleBasisPoints (optional) Basis points for the creator during a reaction sale\n    ///        This is the percentage of the Maker rewards to give to the Creator\n    ///        Basis points are percentage divided by 100 (e.g. 100 Basis Points is 1%)\n    /// @param optionBits - (optional) Params to allow owner to specify options or transformations\n    ///        performed during registration\n    function _registerForOwner(\n        address owner,\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId,\n        address[] memory creatorAddresses,\n        uint256[] memory creatorSaleBasisPoints,\n        uint256 optionBits,\n        string calldata ipfsMetadataHash\n    ) internal {\n        //\n        // \"Source\" - external NFT's\n        // sourceId is derived from [chainId, nftContractAddress, nftId]`\n        // Uses:\n        // - ReactionVault.buyReaction():\n        //    - check that sourceId is registered == true\n        //    - calc creator rewards for makerNFTs\n        // - ReactionVault.withdrawTakerRewards():\n        //    - check that sourceId is registered == true\n        //    - check msg.sender is registered as owner\n        //    - calc creator rewards for takerNFTs\n        //\n        // Generate source ID\n        uint256 sourceId = _deriveSourceId(chainId, nftContractAddress, nftId);\n\n        // add to mapping\n        sourceToDetails[sourceId] = NftDetails(\n            true,\n            owner,\n            creatorAddresses,\n            creatorSaleBasisPoints\n        );\n\n        //\n        // \"Transform\": source NFTs that have been \"transformed\" into fan art via optionBits param\n        // ID: derived from [MAKER_META_PREFIX, registrationSourceId, optionBits]\n        // Uses:\n        // ReactionVault._buyReaction()\n        //  - look up source to make sure its registered\n        //  - used to derive reactionMetaId\n\n        // Generate reaction ID\n        uint256 transformId = uint256(\n            keccak256(abi.encode(MAKER_META_PREFIX, sourceId, optionBits))\n        );\n        // add to mapping\n        transformToSourceLookup[transformId] = sourceId;\n\n        // Emit event\n        emit Registered(\n            chainId,\n            nftContractAddress,\n            nftId,\n            owner,\n            creatorAddresses,\n            creatorSaleBasisPoints,\n            optionBits,\n            sourceId,\n            transformId,\n            ipfsMetadataHash\n        );\n    }\n\n    /// @dev Allow an NFT owner to deregister and remove capability for reactions to be sold.\n    /// Caller must currently own the NFT being deregistered\n    function deregisterNft(address nftContractAddress, uint256 nftId) external {\n        // Verify ownership\n        require(\n            verifyOwnership(nftContractAddress, nftId, msg.sender),\n            \"NFT not owned\"\n        );\n\n        _deregisterNftForOwner(\n            msg.sender,\n            block.chainid,\n            nftContractAddress,\n            nftId\n        );\n    }\n\n    function deRegisterNftFromBridge(\n        address owner,\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId\n    ) external {\n        // Verify caller is Child Registrar from the bridge\n        require(msg.sender == addressManager.childRegistrar(), \"Not Bridge\");\n\n        _deregisterNftForOwner(owner, chainId, nftContractAddress, nftId);\n    }\n\n    function _deregisterNftForOwner(\n        address owner,\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId\n    ) internal {\n        // generate source ID\n        uint256 sourceId = _deriveSourceId(chainId, nftContractAddress, nftId);\n\n        // Verify it is registered\n        NftDetails storage details = sourceToDetails[sourceId];\n        require(details.registered, \"NFT not registered\");\n\n        // Update the param\n        details.registered = false;\n\n        emit Deregistered(chainId, nftContractAddress, nftId, owner, sourceId);\n    }\n\n    function sourceToDetailsLookup(uint256 index)\n        external\n        view\n        returns (NftDetails memory)\n    {\n        return sourceToDetails[index];\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/Permissions/IRoleManager.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\ninterface IRoleManager {\n    /// @dev Determines if the specified address has capability to mint and burn reaction NFTs\n    /// @param potentialAddress Address to check\n    function isAdmin(address potentialAddress) external view returns (bool);\n\n    /// @dev Determines if the specified address has permission to udpate addresses in the protocol\n    /// @param potentialAddress Address to check\n    function isAddressManagerAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to update parameters in the protocol\n    /// @param potentialAddress Address to check\n    function isParameterManagerAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to to mint and burn reaction NFTs\n    /// @param potentialAddress Address to check\n    function isReactionNftAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to purchase curator vault tokens\n    /// @param potentialAddress Address to check\n    function isCuratorVaultPurchaser(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to mint and burn curator tokens\n    /// @param potentialAddress Address to check\n    function isCuratorTokenAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/Maker/IMakerRegistrar.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\n/// @dev Interface for the maker registrar that supports registering and de-registering NFTs\ninterface IMakerRegistrar {\n    /// @dev struct for storing details about a registered NFT\n    struct NftDetails {\n        bool registered;\n        address owner;\n        address[] creators;\n        uint256[] creatorSaleBasisPoints;\n    }\n\n    function transformToSourceLookup(uint256 metaId) external returns (uint256);\n\n    function deriveSourceId(\n        uint256 nftChainId,\n        address nftAddress,\n        uint256 nftId\n    ) external returns (uint256);\n\n    /// @dev lookup for NftDetails from source ID\n    function sourceToDetailsLookup(uint256)\n        external\n        returns (NftDetails memory);\n\n    function verifyOwnership(\n        address nftContractAddress,\n        uint256 nftId,\n        address potentialOwner\n    ) external returns (bool);\n\n    function registerNftFromBridge(\n        address owner,\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId,\n        address[] memory nftCreatorAddresses,\n        uint256[] memory creatorSaleBasisPoints,\n        uint256 optionBits,\n        string memory ipfsMetadataHash\n    ) external;\n\n    function deRegisterNftFromBridge(\n        address owner,\n        uint256 chainId,\n        address nftContractAddress,\n        uint256 nftId\n    ) external;\n}\n"
    },
    "contracts/Maker/MakerRegistrarStorage.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"../Config/IAddressManager.sol\";\nimport \"./IMakerRegistrar.sol\";\n\n/// @title MakerRegistrarStorage\n/// @dev This contract will hold all local variables for the MakerRegistrar Contract\n/// When upgrading the protocol, inherit from this contract on the V2 version and change the\n/// MakerRegistrar to inherit from the later version.  This ensures there are no storage layout\n/// corruptions when upgrading.\nabstract contract MakerRegistrarStorageV1 is IMakerRegistrar {\n    /// @dev local reference to the address manager contract\n    IAddressManager public addressManager;\n\n    /// @dev prefix used in meta ID generation\n    string public constant MAKER_META_PREFIX = \"MAKER\";\n\n    /// @dev Mapping to look up source ID from meta ID key\n    mapping(uint256 => uint256) public override transformToSourceLookup;\n\n    /// @dev Mapping to look up nft details from source ID\n    mapping(uint256 => IMakerRegistrar.NftDetails) public sourceToDetails;\n}\n\n/// On the next version of the protocol, if new variables are added, put them in the below\n/// contract and use this as the inheritance chain.\n/**\ncontract MakerRegistrarStorageV2 is MakerRegistrarStorageV1 {\n  address newVariable;\n}\n */\n"
    },
    "contracts/Maker/NftOwnership.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\ninterface IPunk {\n    function punkIndexToAddress(uint256 index) external view returns (address);\n}\n\n/// @dev This is a library for other contracts to use that need to verify ownership of an NFT on the current chain.\n/// Since this only has internal functions, it will be inlined into the calling contract at\n/// compile time and does not need to be separately deployed on chain.\nlibrary NftOwnership {\n    /// @dev For the specified NFT, verify it is owned by the potential owner\n    function _verifyOwnership(\n        address nftContractAddress,\n        uint256 nftId,\n        address potentialOwner\n    ) internal view returns (bool) {\n        // Try ERC1155\n        try\n            IERC1155Upgradeable(nftContractAddress).balanceOf(\n                potentialOwner,\n                nftId\n            )\n        returns (uint256 balance) {\n            return balance > 0;\n        } catch {\n            // Ignore error\n        }\n\n        // Try ERC721\n        try IERC721Upgradeable(nftContractAddress).ownerOf(nftId) returns (\n            address foundOwner\n        ) {\n            return foundOwner == potentialOwner;\n        } catch {\n            // Ignore error\n        }\n\n        // Try CryptoPunk\n        try IPunk(nftContractAddress).punkIndexToAddress(nftId) returns (\n            address foundOwner\n        ) {\n            return foundOwner == potentialOwner;\n        } catch {\n            // Ignore error\n        }\n\n        return false;\n    }\n}\n"
    },
    "contracts/Royalties/Royalties.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol\";\n\n/// @dev This library uses the Royalty Registry to see if royalties are configured for a specified NFT.\n/// The Royalty Registry looks at a number of sources to see if the original creator set a royalty\n/// configurationon the contract, such as EIP-2981, Manifold, Rarible, etc.\n/// See https://royaltyregistry.xyz/ for more details and deployed addresses.\n/// The output will be a list of addresses and a value that each should receive.\nlibrary Royalties {\n    /// @dev Validate royalties addresses and amounts arrays\n    function _validateRoyalties(\n        address payable[] memory recipients,\n        uint256[] memory amounts\n    ) internal pure returns (bool) {\n        // Verify royalties were found\n        if (recipients.length == 0) {\n            return false;\n        }\n\n        // Verify array lengths match\n        if (recipients.length != amounts.length) {\n            return false;\n        }\n\n        // Calculate the total rewards BP\n        uint256 totalRewardsBp = 0;\n\n        // Verify valid addresses and amounts\n        for (uint8 i = 0; i < recipients.length; i++) {\n            if (recipients[i] == address(0x0)) {\n                return false;\n            }\n\n            if (amounts[i] == 0 || amounts[i] > 10_000) {\n                return false;\n            }\n\n            totalRewardsBp += amounts[i];\n        }\n\n        // Total rewards across all addresses should not be above 100%\n        if (totalRewardsBp > 10_000) {\n            return false;\n        }\n\n        // No issues found, use them\n        return true;\n    }\n\n    /// @dev Gets the royalties for a specified NFT and uses the fallback values if none are found\n    /// A sale price of 10,000 will be used as the value to query since the protocol uses basis points\n    /// to track a percentage of value to send to the creators.  (10k basis points = 100%)\n    function _getRoyaltyOverride(\n        address royaltyRegistry,\n        address nftContractAddress,\n        uint256 nftId,\n        address fallbackCreator,\n        uint256 fallbackCreatorBasisPoints\n    )\n        internal\n        view\n        returns (\n            address[] memory creators,\n            uint256[] memory creatorSaleBasisPoints\n        )\n    {\n        // Query the royalty registry\n        if (royaltyRegistry != address(0x0)) {\n            // Use 10k to get back basis points\n            try\n                IRoyaltyEngineV1(royaltyRegistry).getRoyaltyView(\n                    nftContractAddress,\n                    nftId,\n                    10_000\n                )\n            returns (\n                address payable[] memory recipients,\n                uint256[] memory amounts\n            ) {\n                // Check to see if valid results were found\n                if (_validateRoyalties(recipients, amounts)) {\n                    // Convert to non-payable\n                    // https://github.com/ethereum/solidity/issues/5462\n                    address[] memory convertedAddresses = new address[](\n                        recipients.length\n                    );\n                    for (uint8 i = 0; i < recipients.length; i++) {\n                        convertedAddresses[i] = recipients[i];\n                    }\n\n                    // Use the valid royalties\n                    return (convertedAddresses, amounts);\n                }\n            } catch {\n                // Ignore an errors\n            }\n        }\n        // None found, use fallback address... address 0x0 means no creator rewards\n        address[] memory addressesArray = new address[](1);\n        addressesArray[0] = fallbackCreator;\n\n        // Use fallback value, and ensure it is not above 100%\n        require(fallbackCreatorBasisPoints <= 10_000, \"Invalid bp\");\n        uint256[] memory creatorBasisPointsArray = new uint256[](1);\n        creatorBasisPointsArray[0] = fallbackCreatorBasisPoints;\n\n        return (addressesArray, creatorBasisPointsArray);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Config/IAddressManager.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"../Permissions/IRoleManager.sol\";\nimport \"../Parameters/IParameterManager.sol\";\nimport \"../Maker/IMakerRegistrar.sol\";\nimport \"../Token/IStandard1155.sol\";\nimport \"../Reactions/IReactionVault.sol\";\nimport \"../CuratorVault/ICuratorVault.sol\";\n\ninterface IAddressManager {\n    /// @dev Getter for the role manager address\n    function roleManager() external returns (IRoleManager);\n\n    /// @dev Setter for the role manager address\n    function setRoleManager(IRoleManager _roleManager) external;\n\n    /// @dev Getter for the role manager address\n    function parameterManager() external returns (IParameterManager);\n\n    /// @dev Setter for the role manager address\n    function setParameterManager(IParameterManager _parameterManager) external;\n\n    /// @dev Getter for the maker registrar address\n    function makerRegistrar() external returns (IMakerRegistrar);\n\n    /// @dev Setter for the maker registrar address\n    function setMakerRegistrar(IMakerRegistrar _makerRegistrar) external;\n\n    /// @dev Getter for the reaction NFT contract address\n    function reactionNftContract() external returns (IStandard1155);\n\n    /// @dev Setter for the reaction NFT contract address\n    function setReactionNftContract(IStandard1155 _reactionNftContract)\n        external;\n\n    /// @dev Getter for the default Curator Vault contract address\n    function defaultCuratorVault() external returns (ICuratorVault);\n\n    /// @dev Setter for the default Curator Vault contract address\n    function setDefaultCuratorVault(ICuratorVault _defaultCuratorVault)\n        external;\n\n    /// @dev Getter for the L2 bridge registrar\n    function childRegistrar() external returns (address);\n\n    /// @dev Setter for the L2 bridge registrar\n    function setChildRegistrar(address _childRegistrar) external;\n\n    /// @dev Getter for the address of the royalty registry\n    function royaltyRegistry() external returns (address);\n\n    /// @dev Setter for the address of the royalty registry\n    function setRoyaltyRegistry(address _royaltyRegistry) external;\n}\n"
    },
    "contracts/Parameters/IParameterManager.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"../Permissions/IRoleManager.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IParameterManager {\n    /// @dev Getter for the payment token\n    function paymentToken() external returns (IERC20Upgradeable);\n\n    /// @dev Setter for the payment token\n    function setPaymentToken(IERC20Upgradeable _paymentToken) external;\n\n    /// @dev Getter for the reaction price\n    function reactionPrice() external returns (uint256);\n\n    /// @dev Setter for the reaction price\n    function setReactionPrice(uint256 _reactionPrice) external;\n\n    /// @dev Getter for the cut of purchase price going to the curator liability\n    function saleCuratorLiabilityBasisPoints() external returns (uint256);\n\n    /// @dev Setter for the cut of purchase price going to the curator liability\n    function setSaleCuratorLiabilityBasisPoints(\n        uint256 _saleCuratorLiabilityBasisPoints\n    ) external;\n\n    /// @dev Getter for the cut of purchase price going to the referrer\n    function saleReferrerBasisPoints() external returns (uint256);\n\n    /// @dev Setter for the cut of purchase price going to the referrer\n    function setSaleReferrerBasisPoints(uint256 _saleReferrerBasisPoints)\n        external;\n\n    /// @dev Getter for the cut of spend curator liability going to the taker\n    function spendTakerBasisPoints() external returns (uint256);\n\n    /// @dev Setter for the cut of spend curator liability going to the taker\n    function setSpendTakerBasisPoints(uint256 _spendTakerBasisPoints) external;\n\n    /// @dev Getter for the cut of spend curator liability going to the taker\n    function spendReferrerBasisPoints() external returns (uint256);\n\n    /// @dev Setter for the cut of spend curator liability going to the referrer\n    function setSpendReferrerBasisPoints(uint256 _spendReferrerBasisPoints)\n        external;\n\n    /// @dev Getter for the check to see if a curator vault is allowed to be used\n    function approvedCuratorVaults(address potentialVault)\n        external\n        returns (bool);\n\n    /// @dev Setter for the list of curator vaults allowed to be used\n    function setApprovedCuratorVaults(address vault, bool approved) external;\n}\n"
    },
    "contracts/Token/IStandard1155.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\n/// @dev Interface for the Standard1155 toke contract.\ninterface IStandard1155 {\n    /// @dev Allows a priviledged account to mint tokens to the specified address\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/Reactions/IReactionVault.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @dev Interface for the ReactionVault that supports buying and spending reactions\ninterface IReactionVault {\n    struct ReactionPriceDetails {\n        IERC20Upgradeable paymentToken;\n        uint256 reactionPrice;\n        uint256 saleCuratorLiabilityBasisPoints;\n    }\n}\n"
    },
    "contracts/CuratorVault/ICuratorVault.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"../Token/IStandard1155.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/// @dev Interface for the curator vault\ninterface ICuratorVault {\n    function getTokenId(\n        uint256 nftChainId,\n        address nftAddress,\n        uint256 nftId,\n        IERC20Upgradeable paymentToken\n    ) external returns (uint256);\n\n    function buyCuratorTokens(\n        uint256 nftChainId,\n        address nftAddress,\n        uint256 nftId,\n        IERC20Upgradeable paymentToken,\n        uint256 paymentAmount,\n        address mintToAddress,\n        bool isTakerPosition\n    ) external returns (uint256);\n\n    function sellCuratorTokens(\n        uint256 nftChainId,\n        address nftAddress,\n        uint256 nftId,\n        IERC20Upgradeable paymentToken,\n        uint256 tokensToBurn,\n        address refundToAddress\n    ) external returns (uint256);\n\n    function curatorTokens() external returns (IStandard1155);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Lookup engine interface\n */\ninterface IRoyaltyEngineV1 is IERC165 {\n\n    /**\n     * Get the royalty for a given token (address, id) and value amount.  Does not cache the bps/amounts.  Caches the spec for a given token address\n     * \n     * @param tokenAddress - The address of the token\n     * @param tokenId      - The id of the token\n     * @param value        - The value you wish to get the royalty of\n     *\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\n     */\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value) external returns(address payable[] memory recipients, uint256[] memory amounts);\n\n    /**\n     * View only version of getRoyalty\n     * \n     * @param tokenAddress - The address of the token\n     * @param tokenId      - The id of the token\n     * @param value        - The value you wish to get the royalty of\n     *\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\n     */\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value) external view returns(address payable[] memory recipients, uint256[] memory amounts);\n}"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Bridge/RootRegistrar.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.9;\n\nimport \"./FxBaseRootTunnel.sol\";\nimport \"../Maker/NftOwnership.sol\";\nimport \"../Royalties/Royalties.sol\";\n\n/// @dev This contract lives on the L1 and allows NFT owners to register NFTs that live on the L1.\n/// Once ownership is verified, it will send a message up to the contracts on the L2 specifying that\n/// the NFT has been registered or unregistered.\n/// This is not an upgradeable contract and should not be used with a proxy.\ncontract RootRegistrar is FxBaseRootTunnel {\n    bytes32 public constant REGISTER = keccak256(\"REGISTER\");\n    bytes32 public constant DE_REGISTER = keccak256(\"DE_REGISTER\");\n\n    /// @dev the address that deployed this contract is the only one that can update the fxRootTunnel\n    address public deployer;\n\n    /// @dev the address where the registry royalty is deployed\n    address royaltyRegistry;\n\n    /// @param _checkpointManager This is a well known contract deployed by matic that is used to verify messages coming from the L2 down to L1.\n    /// @param _fxRoot This is a well known contract deployed by matic that will emit the events going from L1 to L2.\n    /// @dev You must call setFxChildTunnel() with the ChildRegistrar address on the L2 after deployment\n    constructor(\n        address _checkpointManager,\n        address _fxRoot,\n        address _royaltyRegistry\n    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {\n        deployer = msg.sender;\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @dev Set fxChildTunnel if not set already\n    /// Only the deploying account can update this\n    /// Overrides the function in the base contract\n    function setFxChildTunnel(address _fxChildTunnel) public override {\n        require(deployer == msg.sender, \"Only deployer\");\n        require(fxChildTunnel == address(0x0), \"Already set\");\n        fxChildTunnel = _fxChildTunnel;\n    }\n\n    /// @dev Allows a NFT owner to register the NFT in the protocol on L1\n    /// Once the ownership is verified a message will be sent to the Child contract\n    /// on the L2 chain that will trigger a registration there.\n    function registerNft(\n        address nftContractAddress,\n        uint256 nftId,\n        address creatorAddress,\n        uint256 creatorSaleBasisPoints,\n        uint256 optionBits,\n        string memory ipfsMetadataHash\n    ) external {\n        // Verify ownership\n        require(\n            NftOwnership._verifyOwnership(\n                nftContractAddress,\n                nftId,\n                msg.sender\n            ),\n            \"NFT not owned\"\n        );\n\n        // Get the royalties for the creator addresses - use fallback if none set on chain\n        (\n            address[] memory addressesArray,\n            uint256[] memory creatorBasisPointsArray\n        ) = Royalties._getRoyaltyOverride(\n                royaltyRegistry,\n                nftContractAddress,\n                nftId,\n                creatorAddress,\n                creatorSaleBasisPoints\n            );\n\n        // REGISTER, encode(owner, chainId, nftContractAddress, nftId, creatorAddress, optionBits, ipfsMetadataHash)\n        bytes memory message = abi.encode(\n            REGISTER,\n            abi.encode(\n                msg.sender,\n                block.chainid,\n                nftContractAddress,\n                nftId,\n                addressesArray,\n                creatorBasisPointsArray,\n                optionBits,\n                ipfsMetadataHash\n            )\n        );\n        _sendMessageToChild(message);\n    }\n\n    /// @dev Allows a NFT owner to de-register the NFT in the protocol on L1\n    /// Once the ownership is verified a message will be sent to the Child contract\n    /// on the L2 chain that will trigger a desgregistration there.\n    function deRegisterNft(address nftContractAddress, uint256 nftId) external {\n        // Verify ownership\n        require(\n            NftOwnership._verifyOwnership(\n                nftContractAddress,\n                nftId,\n                msg.sender\n            ),\n            \"NFT not owned\"\n        );\n\n        // DERegister, encode(address owner, uint256 chainId, address nftContractAddress, uint256 nftId)\n        bytes memory message = abi.encode(\n            DE_REGISTER,\n            abi.encode(msg.sender, block.chainid, nftContractAddress, nftId)\n        );\n        _sendMessageToChild(message);\n    }\n\n    /// @dev NOOP - No messages come from L2 down to L1\n    function _processMessageFromChild(bytes memory data) internal override {}\n}\n"
    },
    "contracts/Bridge/FxBaseRootTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"@maticnetwork/fx-portal/contracts/lib/RLPReader.sol\";\nimport {MerklePatriciaProof} from \"@maticnetwork/fx-portal/contracts/lib/MerklePatriciaProof.sol\";\nimport {Merkle} from \"@maticnetwork/fx-portal/contracts/lib/Merkle.sol\";\nimport \"@maticnetwork/fx-portal/contracts/lib/ExitPayloadReader.sol\";\n\n/// @title FxBaseRootTunnel\n/// @author @maticnetwork\n/// @notice This contract is copied from @maticnetwork/fx-portal\n/// @dev The only change was to make setFxChildTunnel() virtual\n\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data)\n        external;\n}\n\ncontract ICheckpointManager {\n    struct HeaderBlock {\n        bytes32 root;\n        uint256 start;\n        uint256 end;\n        uint256 createdAt;\n        address proposer;\n    }\n\n    /**\n     * @notice mapping of checkpoint header numbers to block details\n     * @dev These checkpoints are submited by plasma contracts\n     */\n    mapping(uint256 => HeaderBlock) public headerBlocks;\n}\n\nabstract contract FxBaseRootTunnel {\n    using RLPReader for RLPReader.RLPItem;\n    using Merkle for bytes32;\n    using ExitPayloadReader for bytes;\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\n    using ExitPayloadReader for ExitPayloadReader.Log;\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\n\n    // keccak256(MessageSent(bytes))\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG =\n        0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\n\n    // state sender contract\n    IFxStateSender public fxRoot;\n    // root chain manager\n    ICheckpointManager public checkpointManager;\n    // child tunnel contract which receives and sends messages\n    address public fxChildTunnel;\n\n    // storage to avoid duplicate exits\n    mapping(bytes32 => bool) public processedExits;\n\n    constructor(address _checkpointManager, address _fxRoot) {\n        checkpointManager = ICheckpointManager(_checkpointManager);\n        fxRoot = IFxStateSender(_fxRoot);\n    }\n\n    // set fxChildTunnel if not set already\n    function setFxChildTunnel(address _fxChildTunnel) public virtual {\n        require(\n            fxChildTunnel == address(0x0),\n            \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\"\n        );\n        fxChildTunnel = _fxChildTunnel;\n    }\n\n    /**\n     * @notice Send bytes message to Child Tunnel\n     * @param message bytes message that will be sent to Child Tunnel\n     * some message examples -\n     *   abi.encode(tokenId);\n     *   abi.encode(tokenId, tokenMetadata);\n     *   abi.encode(messageType, messageData);\n     */\n    function _sendMessageToChild(bytes memory message) internal {\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\n    }\n\n    function _validateAndExtractMessage(bytes memory inputData)\n        internal\n        returns (bytes memory)\n    {\n        ExitPayloadReader.ExitPayload memory payload = inputData\n            .toExitPayload();\n\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\n        uint256 blockNumber = payload.getBlockNumber();\n        // checking if exit has already been processed\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\n        bytes32 exitHash = keccak256(\n            abi.encodePacked(\n                blockNumber,\n                // first 2 nibbles are dropped while generating nibble array\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\n                // so converting to nibble array and then hashing it\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\n                payload.getReceiptLogIndex()\n            )\n        );\n        require(\n            processedExits[exitHash] == false,\n            \"FxRootTunnel: EXIT_ALREADY_PROCESSED\"\n        );\n        processedExits[exitHash] = true;\n\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\n        ExitPayloadReader.Log memory log = receipt.getLog();\n\n        // check child tunnel\n        require(\n            fxChildTunnel == log.getEmitter(),\n            \"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\"\n        );\n\n        bytes32 receiptRoot = payload.getReceiptRoot();\n        // verify receipt inclusion\n        require(\n            MerklePatriciaProof.verify(\n                receipt.toBytes(),\n                branchMaskBytes,\n                payload.getReceiptProof(),\n                receiptRoot\n            ),\n            \"FxRootTunnel: INVALID_RECEIPT_PROOF\"\n        );\n\n        // verify checkpoint inclusion\n        _checkBlockMembershipInCheckpoint(\n            blockNumber,\n            payload.getBlockTime(),\n            payload.getTxRoot(),\n            receiptRoot,\n            payload.getHeaderNumber(),\n            payload.getBlockProof()\n        );\n\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\n\n        require(\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\n            \"FxRootTunnel: INVALID_SIGNATURE\"\n        );\n\n        // received message data\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\n        return message;\n    }\n\n    function _checkBlockMembershipInCheckpoint(\n        uint256 blockNumber,\n        uint256 blockTime,\n        bytes32 txRoot,\n        bytes32 receiptRoot,\n        uint256 headerNumber,\n        bytes memory blockProof\n    ) private view returns (uint256) {\n        (\n            bytes32 headerRoot,\n            uint256 startBlock,\n            ,\n            uint256 createdAt,\n\n        ) = checkpointManager.headerBlocks(headerNumber);\n\n        require(\n            keccak256(\n                abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)\n            ).checkMembership(blockNumber - startBlock, headerRoot, blockProof),\n            \"FxRootTunnel: INVALID_HEADER\"\n        );\n        return createdAt;\n    }\n\n    /**\n     * @notice receive message from  L2 to L1, validated by proof\n     * @dev This function verifies if the transaction actually happened on child chain\n     *\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\n     *  2 - blockNumber - Block number containing the reference tx on child chain\n     *  3 - blockTime - Reference tx block time\n     *  4 - txRoot - Transactions root of block\n     *  5 - receiptRoot - Receipts root of block\n     *  6 - receipt - Receipt of the reference transaction\n     *  7 - receiptProof - Merkle proof of the reference receipt\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\n     *  9 - receiptLogIndex - Log Index to read from the receipt\n     */\n    function receiveMessage(bytes memory inputData) public virtual {\n        bytes memory message = _validateAndExtractMessage(inputData);\n        _processMessageFromChild(message);\n    }\n\n    /**\n     * @notice Process message received from Child Tunnel\n     * @dev function needs to be implemented to handle message as per requirement\n     * This is called by onStateReceive function.\n     * Since it is called via a system call, any event will not be emitted during its execution.\n     * @param message bytes message that was sent from Child Tunnel\n     */\n    function _processMessageFromChild(bytes memory message) internal virtual;\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/RLPReader.sol": {
      "content": "/*\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach out with any questions or concerns\n*/\npragma solidity ^0.8.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item;   // Item that's being iterated over.\n        uint nextPtr;   // Position of the next item in the list.\n    }\n\n    /*\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n    * @param self The iterator.\n    * @return The next element in the iteration.\n    */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n    * @dev Returns true if the iteration has more elements.\n    * @param self The iterator.\n    * @return true if the iteration has more elements.\n    */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @dev Create an iterator. Reverts if item is not a list.\n    * @param self The RLP item.\n    * @return An 'Iterator' over the item.\n    */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint memPtr = item.memPtr + offset;\n        uint len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint memPtr, uint len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            itemLen = 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len == 0) return;\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/MerklePatriciaProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary MerklePatriciaProof {\n    /*\n     * @dev Verifies a merkle patricia proof.\n     * @param value The terminating value in the trie.\n     * @param encodedPath The path in the trie leading to value.\n     * @param rlpParentNodes The rlp encoded stack of nodes.\n     * @param root The root hash of the trie.\n     * @return The boolean validity of the proof.\n     */\n    function verify(\n        bytes memory value,\n        bytes memory encodedPath,\n        bytes memory rlpParentNodes,\n        bytes32 root\n    ) internal pure returns (bool) {\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\n\n        bytes memory currentNode;\n        RLPReader.RLPItem[] memory currentNodeList;\n\n        bytes32 nodeKey = root;\n        uint256 pathPtr = 0;\n\n        bytes memory path = _getNibbleArray(encodedPath);\n        if (path.length == 0) {\n            return false;\n        }\n\n        for (uint256 i = 0; i < parentNodes.length; i++) {\n            if (pathPtr > path.length) {\n                return false;\n            }\n\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\n            if (nodeKey != keccak256(currentNode)) {\n                return false;\n            }\n            currentNodeList = RLPReader.toList(parentNodes[i]);\n\n            if (currentNodeList.length == 17) {\n                if (pathPtr == path.length) {\n                    if (\n                        keccak256(RLPReader.toBytes(currentNodeList[16])) ==\n                        keccak256(value)\n                    ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                uint8 nextPathNibble = uint8(path[pathPtr]);\n                if (nextPathNibble > 16) {\n                    return false;\n                }\n                nodeKey = bytes32(\n                    RLPReader.toUintStrict(currentNodeList[nextPathNibble])\n                );\n                pathPtr += 1;\n            } else if (currentNodeList.length == 2) {\n                uint256 traversed = _nibblesToTraverse(\n                    RLPReader.toBytes(currentNodeList[0]),\n                    path,\n                    pathPtr\n                );\n                if (pathPtr + traversed == path.length) {\n                    //leaf node\n                    if (\n                        keccak256(RLPReader.toBytes(currentNodeList[1])) ==\n                        keccak256(value)\n                    ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                //extension node\n                if (traversed == 0) {\n                    return false;\n                }\n\n                pathPtr += traversed;\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\n            } else {\n                return false;\n            }\n        }\n    }\n\n    function _nibblesToTraverse(\n        bytes memory encodedPartialPath,\n        bytes memory path,\n        uint256 pathPtr\n    ) private pure returns (uint256) {\n        uint256 len = 0;\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n        // and slicedPath have elements that are each one hex character (1 nibble)\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n        bytes memory slicedPath = new bytes(partialPath.length);\n\n        // pathPtr counts nibbles in path\n        // partialPath.length is a number of nibbles\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\n            bytes1 pathNibble = path[i];\n            slicedPath[i - pathPtr] = pathNibble;\n        }\n\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\n            len = partialPath.length;\n        } else {\n            len = 0;\n        }\n        return len;\n    }\n\n    // bytes b must be hp encoded\n    function _getNibbleArray(bytes memory b)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory nibbles = \"\";\n        if (b.length > 0) {\n            uint8 offset;\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\n            if (hpNibble == 1 || hpNibble == 3) {\n                nibbles = new bytes(b.length * 2 - 1);\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\n                nibbles[0] = oddNibble;\n                offset = 1;\n            } else {\n                nibbles = new bytes(b.length * 2 - 2);\n                offset = 0;\n            }\n\n            for (uint256 i = offset; i < nibbles.length; i++) {\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\n            }\n        }\n        return nibbles;\n    }\n\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str)\n        private\n        pure\n        returns (bytes1)\n    {\n        return\n            bytes1(\n                n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10\n            );\n    }\n}"
    },
    "@maticnetwork/fx-portal/contracts/lib/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Merkle {\n    function checkMembership(\n        bytes32 leaf,\n        uint256 index,\n        bytes32 rootHash,\n        bytes memory proof\n    ) internal pure returns (bool) {\n        require(proof.length % 32 == 0, \"Invalid proof length\");\n        uint256 proofHeight = proof.length / 32;\n        // Proof of size n means, height of the tree is n+1.\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\n        require(index < 2 ** proofHeight, \"Leaf index is too big\");\n\n        bytes32 proofElement;\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            assembly {\n                proofElement := mload(add(proof, i))\n            }\n\n            if (index % 2 == 0) {\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n\n            index = index / 2;\n        }\n        return computedHash == rootHash;\n    }\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/ExitPayloadReader.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport { RLPReader } from \"./RLPReader.sol\";\n\nlibrary ExitPayloadReader {\n  using RLPReader for bytes;\n  using RLPReader for RLPReader.RLPItem;\n\n  uint8 constant WORD_SIZE = 32;\n\n  struct ExitPayload {\n    RLPReader.RLPItem[] data;\n  }\n\n  struct Receipt {\n    RLPReader.RLPItem[] data;\n    bytes raw;\n    uint256 logIndex;\n  }\n\n  struct Log {\n    RLPReader.RLPItem data;\n    RLPReader.RLPItem[] list;\n  }\n\n  struct LogTopics {\n    RLPReader.RLPItem[] data;\n  }\n\n  // copy paste of private copy() from RLPReader to avoid changing of existing contracts\n  function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n  function toExitPayload(bytes memory data)\n        internal\n        pure\n        returns (ExitPayload memory)\n    {\n        RLPReader.RLPItem[] memory payloadData = data\n            .toRlpItem()\n            .toList();\n\n        return ExitPayload(payloadData);\n    }\n\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {\n      return payload.data[0].toUint();\n    }\n\n    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {\n      return payload.data[1].toBytes();\n    }\n\n    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {\n      return payload.data[2].toUint();\n    }\n\n    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {\n      return payload.data[3].toUint();\n    }\n\n    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {\n      return bytes32(payload.data[4].toUint());\n    }\n\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {\n      return bytes32(payload.data[5].toUint());\n    }\n\n    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {\n      receipt.raw = payload.data[6].toBytes();\n      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\n\n      if (receiptItem.isList()) {\n          // legacy tx\n          receipt.data = receiptItem.toList();\n      } else {\n          // pop first byte before parsting receipt\n          bytes memory typedBytes = receipt.raw;\n          bytes memory result = new bytes(typedBytes.length - 1);\n          uint256 srcPtr;\n          uint256 destPtr;\n          assembly {\n              srcPtr := add(33, typedBytes)\n              destPtr := add(0x20, result)\n          }\n\n          copy(srcPtr, destPtr, result.length);\n          receipt.data = result.toRlpItem().toList();\n      }\n\n      receipt.logIndex = getReceiptLogIndex(payload);\n      return receipt;\n    }\n\n    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {\n      return payload.data[7].toBytes();\n    }\n\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {\n      return payload.data[8].toBytes();\n    }\n\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {\n      return payload.data[8].toUint();\n    }\n\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {\n      return payload.data[9].toUint();\n    }\n    \n    // Receipt methods\n    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {\n        return receipt.raw;\n    }\n\n    function getLog(Receipt memory receipt) internal pure returns(Log memory) {\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\n        return Log(logData, logData.toList());\n    }\n\n    // Log methods\n    function getEmitter(Log memory log) internal pure returns(address) {\n      return RLPReader.toAddress(log.list[0]);\n    }\n\n    function getTopics(Log memory log) internal pure returns(LogTopics memory) {\n        return LogTopics(log.list[1].toList());\n    }\n\n    function getData(Log memory log) internal pure returns(bytes memory) {\n        return log.list[2].toBytes();\n    }\n\n    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {\n      return log.data.toRlpBytes();\n    }\n\n    // LogTopics methods\n    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {\n      return topics.data[index];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}